//-*- mode: groovy -*-
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.api.tasks.testing.logging.TestExceptionFormat

buildscript {
	repositories {
		mavenCentral()
	}
}

plugins {
	id 'application'
	id 'jacoco'
	id 'java'

	id 'com.diffplug.spotless' version '6.23.3'
	id 'com.gradleup.shadow' version '8.3.0'
	id 'net.nemerosa.versioning' version '3.1.0'
	id 'org.ajoberstar.grgit' version '5.2.2'
	id "com.github.ben-manes.versions" version "0.51.0" // enables ./gradlew dependencyUpdates for outdated

	id 'checkstyle'
}

checkstyle {
	toolVersion = '10.21.1'
}

sourceSets {
	main {
		java {
			srcDirs = ['src']
			destinationDirectory.set(file('build/main'))
		}
		resources {
			srcDirs = ['src']
			excludes = ['**/*.java']
		}
	}

	test {
		java {
			srcDirs = ['test']
			destinationDirectory.set(file('build/test'))
		}
		resources {
			srcDirs = ['test/resources']
		}
	}
}

repositories {
	// Use Maven Central for resolving dependencies.
	mavenCentral()
}

dependencies {
	// Use JUnit Jupiter for running JUnit5 tests.
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.11.0'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter:5.11.0'

	testImplementation 'org.hamcrest:hamcrest:3.0'
	testImplementation 'com.spotify:hamcrest-optional:1.3.2'
	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.11.0'
	testImplementation 'org.junit.jupiter:junit-jupiter-params:5.11.0'
	testImplementation 'org.mockito:mockito-core:5.13.0'
	testImplementation('org.eclipse.xtext:org.eclipse.xtext.xbase.lib:2.36.0') {
		because 'assertion errors including Location/Range/Position need it'
	}
	testImplementation 'org.junit-pioneer:junit-pioneer:2.2.0'

	implementation 'com.formdev:flatlaf:1.6.5'
	implementation 'com.formdev:flatlaf-intellij-themes:1.6.5'
	implementation 'com.formdev:flatlaf-swingx:1.6.5'

	implementation('org.eclipse.lsp4j:org.eclipse.lsp4j:0.23.1') {
		exclude group: 'org.eclipse.xtend', module: 'org.eclipse.xtend.lib'
	}
	implementation 'org.slf4j:slf4j-nop:2.0.16'
	implementation 'org.fusesource.jansi:jansi:2.4.1'
	implementation 'org.swinglabs:swingx:1.0'
	implementation 'com.jgoodies:jgoodies-binding:2.13.0'

	checkstyle "com.puppycrawl.tools:checkstyle:${checkstyle.toolVersion}"
}

application {
	// Define the main class for the application.
	mainClass = 'us.kolmafia.multitool.Multitool'
}

spotless {
	format 'misc', {
		target '.gitignore'

		trimTrailingWhitespace()
		indentWithSpaces(2)
		endWithNewline()
	}

	freshmark {
		target '*.md'
	}

	groovyGradle {
		greclipse()
	}
	java {
		target 'src/**/*.java', 'test/**/*.java'
		googleJavaFormat()
	}
}

tasks.register('cleanDist', Delete) {
	onlyIf {
		file('dist').exists()
	}
	inputs.dir('dist')
	outputs.upToDateWhen { true }
	doLast {
		file('dist').eachFile(groovy.io.FileType.FILES) { File file ->
			if (file.name.startsWith('multitool-') && file.name.endsWith('.jar')) {
				delete file
			}
		}
	}
}

tasks.register('pruneDist', Delete) {
	onlyIf {
		file('dist').exists()
	}
	inputs.dir('dist')
	outputs.upToDateWhen { true }
	doLast {
		file('dist').eachFile(groovy.io.FileType.FILES) { File file ->
			if (file.name.startsWith('multitool-') && file.name.endsWith('.jar')) {
				if (!file.name.contains(project.getVersion().toString()) || (isDirty() != file.name.endsWith('-M.jar'))) {
					delete file
				}
			}
		}
	}
}

test {
	useJUnitPlatform()
	systemProperty 'line.separator', '\n'
	systemProperty 'junit.jupiter.extensions.autodetection.enabled', true
	systemProperty 'useCWDasROOT', true
	systemProperty 'file.encoding', 'UTF-8'
	workingDir 'test/root'

	testLogging.showStandardStreams = true

	reports {
		html.required = true
		junitXml.required = true
	}
}

jacocoTestReport {
	reports {
		xml.required = true
	}
}

jar {
	manifest {
		attributes(
				'Main-Class'      : 'us.kolmafia.multitool.Multitool',
				'Build-Revision'  : new Object() {
					String toString() {
						project.getVersion()
					}
				},
				'Build-Branch'    : versioning.info.branchId,
				'Build-Build'     : versioning.info.build,
				'Build-Dirty'     : isDirty(),
				'Build-Jdk'       : "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
				'Build-OS'        : "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}"
				)
	}

	from {
		configurations.runtimeClasspath.collect {
			it.isDirectory() ? it : zipTree(it)
		}
	} {
		exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
	}
	destinationDirectory = file('dist/')
	archiveBaseName.set('multitool')
	archiveClassifier.set("${isDirty() ? 'M' : ''}")
}

shadowJar {
	mustRunAfter cleanDist
	destinationDirectory = file('dist/')
	archiveClassifier.set("${isDirty() ? 'M' : ''}")
}

tasks.register('getRevision') {
	onlyIf {
		file('.git').exists()
	}
	def commit = findProperty('commit') ?: 'HEAD'
	inputs.dir('.git')
	inputs.property('commit', commit)
	outputs.files file('build/revision.txt')

	doLast {
		def revision = grgit.log(includes: [commit]).size() - localCommits(commit)
		logger.info('Commit: {} Revision: {}', commit, revision)
		file('build/revision.txt').text = revision.toString().trim()
		// Update the version to the new revision
		project.setVersion(revision.toString().trim())
		def revString = isDirty() ? project.getVersion() + 'M' : project.getVersion()
		println '\nRevision: ' + revString
	}
}

tasks.register('gitUpdate') {
	doLast {
		def remote = grgit.branch.current().trackingBranch.getName()
		def latestHead = grgit.resolve.toCommit(remote)
		grgit.fetch {
			remote = remote
		}
		if (grgit.resolve.toCommit(remote) == latestHead) {
			println 'Already up-to-date, nothing to do.'
			return
		}
		def dirty = isDirty()
		if (dirty) {
			// This pollutes the reflog, but there's no stash functionality in
			// grgit...
			grgit.commit {
				message = 'temporary stash commit'
				all = true
			}
		}
		grgit.pull {
			rebase = true
		}
		if (dirty) {
			grgit.reset {
				mode = 'mixed'
				commit = 'HEAD^'
			}
		}
	}
}

java {
	sourceCompatibility = JavaVersion.toVersion(javaSourceCompatibility)
	targetCompatibility = JavaVersion.toVersion(javaTargetCompatibility)
}

tasks.withType(Checkstyle).configureEach {
	maxHeapSize = '2g'
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8'
}

tasks.withType(Test).configureEach {
	// Mockito requires dynamic loading for mock creation.
	jvmArgs("-XX:+EnableDynamicAgentLoading")
	testLogging {
		events TestLogEvent.FAILED,
				TestLogEvent.SKIPPED,
				TestLogEvent.STANDARD_ERROR,
				TestLogEvent.STANDARD_OUT
		exceptionFormat = TestExceptionFormat.FULL
	}
}

tasks.register('cleanJpackage', Delete) {
	onlyIf {
		file('build/releases').exists()
	}
	delete 'build/releases'
}

gradle.taskGraph.whenReady { graph ->
	if (graph.hasTask(":tsDefs") || graph.hasTask(":test")) {
		compileJava.options.compilerArgs += "-parameters"
	}
}

clean.dependsOn cleanDist
pruneDist.dependsOn getRevision

// Note that pruneDist relies on getRevision.
jar.dependsOn pruneDist
shadowJar.dependsOn pruneDist

startShadowScripts.dependsOn jar
startScripts.dependsOn jar

distTar.dependsOn shadowJar
distZip.dependsOn shadowJar
startScripts.dependsOn shadowJar

jacocoTestReport.dependsOn test

def isDirty() {
	return versioning.info.dirty || localCommits(findProperty('commit') ?: 'HEAD') > 0
}

def localCommits(commit) {
	return grgit.log(includes:[commit], excludes:['origin/main']).size()
}

def lastRevision() {
	def revisionFile = file('build/revision.txt')
	return revisionFile.exists() ? revisionFile.text.trim() : '0'
}

// Set version from last build/revision.txt if up-to-date
version = lastRevision()
